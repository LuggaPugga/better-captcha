import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import process from "node:process";
import { PROVIDER_REGISTRY, type ProviderMetadata } from "@better-captcha/core/src/registry";

function generateComponentFile(metadata: ProviderMetadata): string {
	const { name, componentName, providerClassName, handleType, renderParamsType, renderParamsOmit, extraTypes } =
		metadata;

	const extraTypeImports = extraTypes.length > 0 ? `,\n\ttype ${extraTypes.join(",\n\ttype ")}` : "";
	const extraTypeExports = extraTypes.length > 0 ? `, ${extraTypes.join(", ")}` : "";

	return `// Auto-generated from @better-captcha/core
// Do not edit this file directly
"use client";

import { createCaptchaComponent } from "../../base-captcha";
import {
	${providerClassName},
	type ${handleType},
	type ${renderParamsType}${extraTypeImports},
} from "@better-captcha/core/providers/${name}";

export const ${componentName} = createCaptchaComponent<
	Omit<${renderParamsType}, ${renderParamsOmit}>,
	${handleType}
>(${providerClassName});

export type { ${handleType}, ${renderParamsType}${extraTypeExports} };
`;
}

function generateIndexFile(metadata: ProviderMetadata): string {
	const { componentName, handleType, renderParamsType, extraTypes, name } = metadata;
	const extraTypeExports = extraTypes.length > 0 ? `, ${extraTypes.join(", ")}` : "";

	return `// Auto-generated from @better-captcha/core
// Do not edit this file directly
export { ${componentName} } from "./${name}";
export type { ${handleType}, ${renderParamsType}${extraTypeExports} } from "./${name}";
`;
}

function generateAggregateIndexFile(providers: ProviderMetadata[]): string {
	const lines = ["// Auto-generated from @better-captcha/core", "// Do not edit this file directly", ""];

	for (const metadata of providers) {
		const { name, componentName, handleType, renderParamsType, extraTypes } = metadata;
		lines.push(`export { ${componentName} } from "./${name}";`);
		lines.push(`export type { ${handleType} } from "./${name}";`);
		lines.push(`export type { ${renderParamsType} as ${componentName}${renderParamsType} } from "./${name}";`);

		for (const extraType of extraTypes) {
			lines.push(`export type { ${extraType} as ${componentName}${extraType} } from "./${name}";`);
		}
	}

	return lines.join("\n");
}

function writeFile(filePath: string, content: string): void {
	const dir = join(filePath, "..");
	if (!existsSync(dir)) {
		mkdirSync(dir, { recursive: true });
	}
	writeFileSync(filePath, content, "utf-8");
}

function generateProviderComponents(metadata: ProviderMetadata): void {
	const outputPath = join(process.cwd(), "src/provider");
	const componentPath = join(outputPath, metadata.name);

	if (!existsSync(componentPath)) {
		mkdirSync(componentPath, { recursive: true });
	}

	writeFile(join(componentPath, `${metadata.name}.tsx`), generateComponentFile(metadata));
	writeFile(join(componentPath, "index.ts"), generateIndexFile(metadata));
}

function logProviderInfo(metadata: ProviderMetadata): void {
	console.log(`‚úÖ Generated: ${metadata.componentName} (${metadata.name})`);
	console.log(`   Provider: ${metadata.providerClassName}`);
	console.log(`   Handle: ${metadata.handleType}`);
	console.log(`   Omit: ${metadata.renderParamsOmit}`);

	if (metadata.extraTypes.length > 0) {
		console.log(`   Extra Types: ${metadata.extraTypes.join(", ")}`);
	}
	console.log();
}

function main(): void {
	console.log("üöÄ Generating SolidJS components from core providers...\n");

	const outputPath = join(process.cwd(), "src/provider");
	if (!existsSync(outputPath)) {
		mkdirSync(outputPath, { recursive: true });
	}

	const providers = PROVIDER_REGISTRY;

	if (providers.length === 0) {
		console.error("‚ùå No providers found!");
		process.exit(1);
	}

	for (const metadata of providers) {
		try {
			generateProviderComponents(metadata);
			logProviderInfo(metadata);
		} catch (error) {
			console.error(`‚ùå Failed to generate: ${metadata.componentName} - ${error}`);
			process.exit(1);
		}
	}

	try {
		writeFile(join(outputPath, "index.ts"), generateAggregateIndexFile(providers));
		console.log(`‚ú® Successfully generated ${providers.length} SolidJS component${providers.length !== 1 ? "s" : ""}!`);
	} catch (error) {
		console.error(`‚ùå Failed to write aggregate provider index: ${error}`);
		process.exit(1);
	}
}

main();
