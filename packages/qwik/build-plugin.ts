import path from "node:path";
import { PROVIDER_REGISTRY, type ProviderMetadata } from "@better-captcha/core";
import {
	type FrameworkConfig,
	generateProviderAggregateModule,
	generateProviderModuleDts,
	type GeneratedFiles,
	generateAggregateIndexFile,
} from "@better-captcha/core/utils/build-plugin-utils";
import { Project, ScriptTarget, ModuleKind, VariableDeclarationKind } from "ts-morph";
import { createUnplugin } from "unplugin";

const BASE_SPEC = "@better-captcha/qwik/base";
const PROVIDER_AGG_SPEC = "@better-captcha/qwik/provider";
const PROVIDER_SPEC_PREFIX = "@better-captcha/qwik/provider/";

function toPosix(p: string): string {
	return p.split(path.sep).join("/");
}

function createProject(): Project {
	return new Project({
		useInMemoryFileSystem: true,
		compilerOptions: {
			target: ScriptTarget.ESNext,
			module: ModuleKind.ESNext,
			declaration: true,
			esModuleInterop: true,
			skipLibCheck: true,
		},
	});
}

const qwikConfig: FrameworkConfig = {
	baseImport: `import { createCaptchaComponent } from "${BASE_SPEC}";`,
	componentCreation: (providerClassName: string) => {
		return `createCaptchaComponent($((identifier: string) => new ${providerClassName}(identifier)))`;
	},
	componentType: "Component",
	componentTypeImports: '{ Component } from "@builder.io/qwik"',
	fileExtension: ".js",
	propsStructure: "two-params",
};

function genProviderModule(meta: ProviderMetadata): string {
	const project = createProject();
	const sourceFile = project.createSourceFile("provider.ts", "", { overwrite: true });

	sourceFile.addImportDeclaration({
		namedImports: ["$"],
		moduleSpecifier: "@builder.io/qwik",
	});

	sourceFile.addImportDeclaration({
		namedImports: ["createCaptchaComponent"],
		moduleSpecifier: BASE_SPEC,
	});

	sourceFile.addImportDeclaration({
		namedImports: [meta.providerClassName],
		moduleSpecifier: `@better-captcha/core/providers/${meta.name}`,
	});

	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const,
		declarations: [
			{
				name: `${meta.componentName}Factory`,
				initializer: `$((value: string) => new ${meta.providerClassName}(value))`,
			},
		],
	});

	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const,
		isExported: true,
		declarations: [
			{
				name: meta.componentName,
				initializer: `createCaptchaComponent(${meta.componentName}Factory)`,
			},
		],
	});

	const emitResult = project.emitToMemory();
	const files = emitResult.getFiles();
	return files.find((f) => f.filePath.endsWith(".js"))?.text || "";
}

function genProviderModuleDts(meta: ProviderMetadata): GeneratedFiles {
	return generateProviderModuleDts(meta, qwikConfig);
}

function genProviderAggregateModule(): string {
	const files = generateProviderAggregateModule(PROVIDER_REGISTRY, PROVIDER_SPEC_PREFIX);
	return files.js;
}

function genProviderAggregateModuleDts(): string {
	const files = generateAggregateIndexFile(PROVIDER_REGISTRY, ".qwik.mjs");
	return files.dts;
}

export const unplugin = createUnplugin(() => {
	const baseAbs = toPosix(path.resolve(process.cwd(), "src/base-captcha.tsx"));

	return {
		name: "better-captcha-qwik",
		enforce: "pre",

		resolveId(id) {
			if (id === BASE_SPEC) return id;
			if (id === PROVIDER_AGG_SPEC) return id;
			if (id.startsWith(PROVIDER_SPEC_PREFIX)) return id;
			return null;
		},

		load(id) {
			if (id === BASE_SPEC) {
				return {
					code: `export { createCaptchaComponent } from "${baseAbs}";`,
					map: null,
				};
			}
			if (id === PROVIDER_AGG_SPEC) {
				return {
					code: genProviderAggregateModule(),
					map: null,
				};
			}
			if (id.startsWith(PROVIDER_SPEC_PREFIX)) {
				const name = id.slice(PROVIDER_SPEC_PREFIX.length);
				const meta = PROVIDER_REGISTRY.find((p) => p.name === name);
				if (!meta) return { code: "export {}", map: null };
				return {
					code: genProviderModule(meta),
					map: null,
				};
			}
			return null;
		},
	};
});

function genProviderModuleJs(meta: ProviderMetadata): string {
	const project = createProject();
	const sourceFile = project.createSourceFile("temp.ts", "", { overwrite: true });

	// Add header comments
	sourceFile.addStatements([
		"// Auto-generated from @better-captcha/core",
		"// Do not edit this file directly",
	]);

	// Add imports
	sourceFile.addImportDeclaration({
		namedImports: ["$"],
		moduleSpecifier: "@builder.io/qwik",
	});

	sourceFile.addImportDeclaration({
		namedImports: ["createCaptchaComponent"],
		moduleSpecifier: "../../base-captcha.qwik.mjs",
	});

	sourceFile.addImportDeclaration({
		namedImports: [meta.providerClassName],
		moduleSpecifier: `@better-captcha/core/providers/${meta.name}`,
	});

	// Add factory constant
	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const, // const
		declarations: [
			{
				name: `${meta.componentName}Factory`,
				initializer: `$(\n    (value) => new ${meta.providerClassName}(value),\n)`,
			},
		],
	});

	// Add component export
	sourceFile.addVariableStatement({
		declarationKind: VariableDeclarationKind.Const, // const
		isExported: true,
		declarations: [
			{
				name: meta.componentName,
				initializer: `createCaptchaComponent(${meta.componentName}Factory)`,
			},
		],
	});

	return sourceFile.getFullText();
}

function genProviderModuleCjs(meta: ProviderMetadata): string {
	// For CommonJS, we need to use a different approach since ts-morph doesn't directly support CJS
	// We'll generate it as a string but with better structure
	const lines: string[] = [];

	lines.push("// Auto-generated from @better-captcha/core");
	lines.push("// Do not edit this file directly");
	lines.push("");
	lines.push('const { $ } = require("@builder.io/qwik");');
	lines.push(`const { createCaptchaComponent } = require("../../base-captcha.qwik.cjs");`);
	lines.push(`const { ${meta.providerClassName} } = require("@better-captcha/core/providers/${meta.name}");`);
	lines.push("");
	lines.push(`const ${meta.componentName}Factory = $(`);
	lines.push(`    (value) => new ${meta.providerClassName}(value),`);
	lines.push(");");
	lines.push("");
	lines.push(
		`exports.${meta.componentName} = createCaptchaComponent(${meta.componentName}Factory);`,
	);

	return lines.join("\n");
}

function genProviderAggregateModuleJs(): string {
	const project = createProject();
	const sourceFile = project.createSourceFile("temp.ts", "", { overwrite: true });

	// Add header comments
	sourceFile.addStatements([
		"// Auto-generated from @better-captcha/core",
		"// Do not edit this file directly",
	]);

	// Add exports for each provider
	for (const m of PROVIDER_REGISTRY) {
		sourceFile.addExportDeclaration({
			namedExports: [m.componentName],
			moduleSpecifier: `./${m.name}/index.qwik.mjs`,
		});
	}

	return sourceFile.getFullText();
}

function genProviderAggregateModuleCjs(): string {
	// CommonJS aggregate - using string building for better control
	const lines: string[] = [];
	lines.push("// Auto-generated from @better-captcha/core");
	lines.push("// Do not edit this file directly");
	lines.push("");

	for (const m of PROVIDER_REGISTRY) {
		lines.push(`const { ${m.componentName}: _${m.componentName} } = require("./${m.name}/index.qwik.cjs");`);
		lines.push(`exports.${m.componentName} = _${m.componentName};`);
	}

	return lines.join("\n");
}

function genIndexDts(): string {
	const project = createProject();
	const sourceFile = project.createSourceFile("temp.d.ts", "", { overwrite: true });

	// Add header comments
	sourceFile.addStatements([
		"// Auto-generated from @better-captcha/core",
		"// Do not edit this file directly",
	]);

	// Add type imports
	sourceFile.addImportDeclaration({
		namedImports: ["CaptchaHandle"],
		moduleSpecifier: "@better-captcha/core",
		isTypeOnly: true,
	});

	sourceFile.addImportDeclaration({
		namedImports: ["NoSerialize", "QRL", "Signal"],
		moduleSpecifier: "@builder.io/qwik",
		isTypeOnly: true,
	});

	// Re-export core types
	sourceFile.addExportDeclaration({
		namedExports: ["CaptchaHandle", "CaptchaState", "Provider", "ProviderConfig", "WidgetId"],
		moduleSpecifier: "@better-captcha/core",
		isTypeOnly: true,
	});

	// Add CaptchaProps types with JSDoc
	sourceFile.addTypeAlias({
		name: "CaptchaSharedProps",
		typeParameters: [
			{ name: "TOptions" },
			{ name: "THandle", constraint: "CaptchaHandle", default: "CaptchaHandle" },
		],
		type: `{
	options?: TOptions;
	class?: string;
	style?: string | Record<string, string | number>;
	onReady$?: QRL<(handle: NoSerialize<THandle>) => unknown>;
	onError$?: QRL<(error: Error) => unknown>;
	controller?: { value: NoSerialize<THandle> | null } | null;
	autoRender?: boolean;
}`,
		isExported: true,
	});

	sourceFile.addTypeAlias({
		name: "CaptchaProps",
		typeParameters: [
			{ name: "TOptions" },
			{ name: "THandle", constraint: "CaptchaHandle", default: "CaptchaHandle" },
		],
		type: `CaptchaSharedProps<TOptions, THandle> & {
	sitekey: string;
	endpoint?: never;
}`,
		isExported: true,
		docs: [
			{
				description:
					"Props for CAPTCHA components\n@template TOptions - Type of options specific to the CAPTCHA provider\n@template THandle - Type of handle returned by the CAPTCHA provider",
			},
		],
	});

	sourceFile.addTypeAlias({
		name: "CaptchaPropsWithEndpoint",
		typeParameters: [
			{ name: "TOptions" },
			{ name: "THandle", constraint: "CaptchaHandle", default: "CaptchaHandle" },
		],
		type: `CaptchaSharedProps<TOptions, THandle> & {
	endpoint: string;
	sitekey?: never;
}`,
		isExported: true,
	});

	// Export createCaptchaComponent helpers
	sourceFile.addExportDeclaration({
		namedExports: ["createCaptchaComponent", "createCaptchaComponentWithEndpoint"],
		moduleSpecifier: "./base-captcha.qwik.mjs",
	});

	// Add CaptchaController type
	sourceFile.addTypeAlias({
		name: "CaptchaController",
		typeParameters: [{ name: "THandle", constraint: "CaptchaHandle", default: "CaptchaHandle" }],
		type: "Signal<NoSerialize<THandle> | null>",
		isExported: true,
	});

	// Add useCaptchaController function declaration
	sourceFile.addFunction({
		name: "useCaptchaController",
		typeParameters: [{ name: "THandle", constraint: "CaptchaHandle", default: "CaptchaHandle" }],
		returnType: "CaptchaController<THandle>",
		isExported: true,
		docs: [
			{
				description:
					"Creates a controller for managing CAPTCHA component instances\n@template THandle - Type of handle returned by the CAPTCHA provider\n@returns A signal that can be used to control the CAPTCHA component",
			},
		],
	});

	return sourceFile.getFullText();
}

function genBaseCaptchaDts(): string {
	const project = createProject();
	const sourceFile = project.createSourceFile("temp.d.ts", "", { overwrite: true });

	// Add header comments
	sourceFile.addStatements([
		"// Auto-generated from @better-captcha/core",
		"// Do not edit this file directly",
	]);

	// Add type imports
	sourceFile.addImportDeclaration({
		namedImports: ["CaptchaHandle", "Provider", "ProviderConfig"],
		moduleSpecifier: "@better-captcha/core",
		isTypeOnly: true,
	});

	sourceFile.addImportDeclaration({
		namedImports: ["Component", "NoSerialize", "QRL"],
		moduleSpecifier: "@builder.io/qwik",
		isTypeOnly: true,
	});

	sourceFile.addImportDeclaration({
		namedImports: ["CaptchaProps", "CaptchaPropsWithEndpoint", "CaptchaController"],
		moduleSpecifier: "./index",
		isTypeOnly: true,
	});

	// Add createCaptchaComponent function declarations
	sourceFile.addFunction({
		name: "createCaptchaComponent",
		typeParameters: [
			{ name: "TOptions", default: "unknown" },
			{ name: "THandle", constraint: "CaptchaHandle", default: "CaptchaHandle" },
			{
				name: "TProvider",
				constraint: "Provider<ProviderConfig, TOptions, THandle>",
				default: "Provider<ProviderConfig, TOptions, THandle>",
			},
		],
		parameters: [
			{
				name: "providerFactory$",
				type: "QRL<(value: string) => TProvider>",
			},
		],
		returnType: "Component<CaptchaProps<TOptions, THandle>>",
		isExported: true,
		hasDeclareKeyword: true,
	});

	sourceFile.addFunction({
		name: "createCaptchaComponentWithEndpoint",
		typeParameters: [
			{ name: "TOptions", default: "unknown" },
			{ name: "THandle", constraint: "CaptchaHandle", default: "CaptchaHandle" },
			{
				name: "TProvider",
				constraint: "Provider<ProviderConfig, TOptions, THandle>",
				default: "Provider<ProviderConfig, TOptions, THandle>",
			},
		],
		parameters: [
			{
				name: "providerFactory$",
				type: "QRL<(value: string) => TProvider>",
			},
		],
		returnType: "Component<CaptchaPropsWithEndpoint<TOptions, THandle>>",
		isExported: true,
		hasDeclareKeyword: true,
	});

	return sourceFile.getFullText();
}

export const dtsEmitterPlugin = createUnplugin(() => {
	return {
		name: "better-captcha-dts-emitter",
		vite: {
			enforce: "post",
		},

		generateBundle() {
			this.emitFile({
				type: "asset",
				fileName: "index.d.ts",
				source: genIndexDts(),
			});

			this.emitFile({
				type: "asset",
				fileName: "base-captcha.d.ts",
				source: genBaseCaptchaDts(),
			});

			for (const provider of PROVIDER_REGISTRY) {
				this.emitFile({
					type: "asset",
					fileName: `provider/${provider.name}/index.qwik.mjs`,
					source: genProviderModuleJs(provider),
				});

				this.emitFile({
					type: "asset",
					fileName: `provider/${provider.name}/index.qwik.cjs`,
					source: genProviderModuleCjs(provider),
				});

				const dtsFiles = genProviderModuleDts(provider);
				this.emitFile({
					type: "asset",
					fileName: `provider/${provider.name}/index.d.ts`,
					source: dtsFiles.dts,
				});
			}

			this.emitFile({
				type: "asset",
				fileName: "provider/index.qwik.mjs",
				source: genProviderAggregateModuleJs(),
			});

			this.emitFile({
				type: "asset",
				fileName: "provider/index.qwik.cjs",
				source: genProviderAggregateModuleCjs(),
			});

			this.emitFile({
				type: "asset",
				fileName: "provider/index.d.ts",
				source: genProviderAggregateModuleDts(),
			});
		},
	};
});

export default unplugin;
